// Serial C Library (Linux style)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <termios.h>

#include "../Include/Picaso_Types4D.h"			// defines data types used by the 4D Routines
#include "../Include/Picaso_const4DSerial.h"	// function call index definitions, generated by build of serial
#include "../Include/Picaso_const4D.h"			// defines for 4dgl constants, generated by conversion of 4DGL constants to target language

#define   Err4D_OK      0
#define   Err4D_Timeout 1
#define   Err4D_NAK		2 // other than ACK received


// 4D Global variables
int    fdComm;  		// comp port handle, used by Intrinsic routines
int    Error4D ;  				// Error indicator,  used and set by Intrinsic routines
unsigned char Error4D_Inv ;	// Error byte returned from com port, onl set if error = Err_Invalid
int Error_Abort4D ;  		// if true routines will abort when detecting an error
int TimeLimit4D ;			// time limit in ms for total serial command duration, 2000 (2 seconds) should be adequate for most commands
                            // assuming a reasonable baud rate AND low latency AND 0 for the Serial Delay Parameter
                            // temporary increase might be required for very long (bitmap write, large image file opens)
int(*Callback4D) (int, unsigned char) ;                            // or indeterminate (eg file_exec, file_run, file_callFunction)  commands

#include "Picaso_Intrinsic4DRoutines.inc"
#include "Picaso_Compound4DRoutines.inc"

int OpenComm(char *sDeviceName, int newrate)
{
    char sPortName[32];
    int nMode = O_RDWR | O_NOCTTY | O_NDELAY;
    int k, ch, tSave;

    sprintf(sPortName, "/dev/%s", sDeviceName);

#ifndef COMMS_TEST
    fdComm = open(sPortName, nMode);
    if (fdComm < 0)
    {
        printf("open error %d %s\n", errno, strerror(errno));
        return fdComm;
    }

    // Set the line to RAW
    SetBaudrate(newrate);

    // Set non-blocking
    fcntl(fdComm, F_SETFL, FNDELAY);

    // Try to overcome a bug with the Raspberry Pi (or indeed, any other serial
    //	port that sends a garbage character when you first open it),
    //	by sending out dummy characters until we get a NAK back, hopefully
    //	then the display sequencer will be in a stable state.

    tSave = TimeLimit4D;
    TimeLimit4D = 500;
    for (k = 0 ; k < 10 ; k++)
    {
        ch = 'X';
        write(fdComm, (unsigned char *)&ch, 1);
        ReadSerPort((unsigned char *)&ch, 1);
        if (ch == 0x15)
            break ;
    }
    TimeLimit4D = tSave;

    tcflush(fdComm, TCIOFLUSH);
#else
    // Quietly signal no device available
    fdComm = -1;
    Error4D = Err4D_OK;
#endif
    return 0;
}

void CloseComm(void)
{
    close(fdComm);
    fdComm = -1;
    Error4D = Err4D_OK;

    return;
}
